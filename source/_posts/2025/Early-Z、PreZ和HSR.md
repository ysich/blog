---
title: Early-Z、PreZ和HSR
date: 2025-05-09 17:02:05
categories: 性能优化篇
tags:渲染 性能优化
---

# Early-Z、PreZ和HSR

Early-Z、PreZ和HSR都是为了解决OverDraw导致的渲染性能问题存在的。

这三者都是通过片元深度值来达到提升性能的目的，片元的深度值是通过三角形遍历对三角形顶点的深度值进行插值获得的，也就是在片元着色器前就已经拥有了片元深度（这好像是句废话）。

## Early-Z

Early-Z是通过GPU独立硬件而实现的，为了避免渲染了最后会被ZTest丢弃的片元，所以将ZTest提前到片元着色器之前执行，通过光栅化后得到的每个片元的深度进行提前测试，首先进行DepthRead & Test，通过后直接Write。但是Early-Z能做到的只是缓解，不能真正解决这个问题。因为在渲染场景时，会对物体进行排序，而这个排序只能做到大致准确无法做到完全准确，排序的级别是物体而不是像素。比如经典的三角形循环堆叠的问题，三个三角形互相遮挡无论怎么排序都会先绘制一个再绘制另外一个。所以在相互堆叠的物体密度较高的情况下，还是存在很多无法通过early-z提前丢弃，而走到后续渲染流程中没有任意意义的片元。

Early-Z也存在一些限制，AlphaTest或者Depth Modfiy都会导致Early-Z失效

## ![i1](Early-Z、PreZ和HSR\i1.png)

## Z-PrePass

Z-PrePass则是通过一个提前的Pass仅仅只写入深度，不输出任何的颜色。(在另一个正常绘制的Pass则需要关闭深度写入，打开深度测试)只使用顶点和极简的片元着色器。Pre-Z的存在是为了增强Early-Z的，通过一个额外的Pass来消除Early-Z因为物体排序和AlphaTest带来的影响。在额外的Pass里进行所有深度的写入，和进行透明度测试，保证Early-Z能够高效顺利的进行。PrePass只对不透明度物体和AlphaTest进行提前写入深度，所以对于不透明度物体和AlphaTest物体会多一倍的DrawCall。PrePass的性能瓶颈则是物体的顶点数量，因为需要额外的Pass处理顶点着色器和片元着色器，如果都是顶点数非常大的模型可能并不划算，如果是类似于草这种大量并且面数低的模型是会得到性能提升的。

## HSR

HSR则是TBDR中独有的，HSR可以完全解决OverDraw。HSR通过硬件层面实现了零OverDraw，当一个片元通过Early-Z准备执行PS前，先不进行绘制，只记录这个像素归于哪个图元绘制，等这个Tile上的所有图元都处理完了，再真正的开始绘制每个图元中被标记上能绘制的像素点(进入PS)。这样每个像素实际上都只执行了最后通过early-z的片元的PS。基于TBR架构，Tile块中所有图元的信息都在片上，可以极小代价获得。

![i2](Early-Z、PreZ和HSR\i2.png)

HSR基于TBDR架构将帧缓冲区基于Tile进行划分，通过延迟操作等到Tile上的图元全部光栅化并且HSR处理完成后，再进行后续的片元着色流程。

HSR在遇到AlphaTest & AlphaBlend时也会导致性能降低(相比于不透明物体而已)。当遇到AlphaTest时，由于HSR假定前面的物体会挡住后面的物体，为了保证渲染正确必须终止当前的Defer，将标记好的像素先进行绘制，等AlphaTest处理完成后，再进行后面的流程。

而AlphaBlend同样也需要中断Defer，进行强制绘制，但是相比于AlphaTest而已不会影响后续图元并行地继续开始进行HSR处理。虽然和AlphaTest意义都会打断延迟绘制流程，但是后续的图元可以不受阻碍的按照HSR的机制，并行进行深度检测、标记等操作。
